Object representation:

Rel1 (pose)
...
RelN (pose)

Pnts (Clr,X)

Poses and X are in the obj RF.



predict_objs (time t)
    for each object
        object.state(t) = object.predict_model(t)
    

class state_type
{
    location;
    velocity;
    acceleration;
}

class object_point_type
{
    location_type X;
    color_type Clr;
    
    move(object_move_type);
}

class object_move_type
{
}

class relation_type
{
    location_type anchor;
    vector3 orientation;
    object_move_type calculate_object_move(relation_type)
    {
    }
}

class object_type
{
    map(time_type, state_type) state;
    
    list<object_point_type> points;
    list<relation_type> relations;
    
    predict_model(time t)
    {
        acceleration(t) = force/mass;
        velocity(t) = object.velocity(t_prev)+object.acceleration(t)*(t-t_prev);
        X(t) = X(t_prev) + velocity(t)*(t-t_prev);
    }
    
    add_relation(relation_type relation )
    {
        relations.push_back(relation);
    }
    
    add_point(object_point_type point)
    {
        points.add_point(point);
    }
    
    bool valid()
    {
        return (points.size()>threshold);
    }

    relation_type find_matching_relation(relation_type relation)
    {
    }
    
    event_type calculate_event_from_relation_move(observed_scene_type observed_scene, relation_type relation)
    {
        relation_type matching_relation = find_matching_relation(relation);
        object_move_type object_move = matching_relation.calculate_object_move(relation);

        for (auto object_point in points) 
        {
            if (!observed_scene.contains_point(object_point.move(object_move))
                return null;
        }
        
        event_type event(object, object_move);
        return event;
    }    
}

class event_type
{
    object_type object;
    object_move_type move;
    
    event_type(object_type object, object_move_type move)
    {
        this->object = object;
        this->move = move;
    }

    execute()
    {
        object.move();
    }
}

class plan_type
{
    list<plan_type> plan_steps;
    
    event_type cause;
    event_type effect;
    
    plan_type(event_type cause, event_type effect)
    {
        this->cause = cause;
        this->effect = effect;
    }
    
    add_step_to_plan(plan_type plan_step)
    {
        plan_steps.push_back(plan_step);
    }
    
    execute()
    {
        for (plan_step in plan_steps)
        {
            plan_step.execute();
        }
        cause.execute();
    }
}

class observed_scene_type
{
    list <object_point_type> points;
    list<relation_type> relations;
    
    calculate_relations()
    {
    }
    
    relation_type find_matching_relation(relation_type relation)
    {
    }
    
    bool contains_point(object_point_type point)
    {
    }
    
    event_type calculate_object_from_relation_move(observed_scene_type observed_scene, relation_type relation)
    {
        relation_type matching_relation = find_matching_relation(relation);
        object_move_type object_move = matching_relation.calculate_object_move(relation);
        object_type object;
        object.add_relation(relation);
        for (auto scene_point in points) 
        {
            if (observed_scene.contains_point(scene_point.move(object_move))
                object.add_point(scene_point);
        }
        
        event_type event(object, object_move);
        return event;
    }
}


class ai_system
{
    list <goal_type> goals;
    list <plan_type> possible_plans;
    list <plan_type> executed_plans;
    list <observed_scene_type> observed_scenes;    
    list <object_type> objects;
    list <event_type> events;
    
    lifecycle()
    {
        observe_world();
        learn_possible_plans();
        calculate_goals();
        assemble_plans_to_achieve_goals();
        execute_plans();
    }

    observe_world()
    {
        observed_scene_type observed_scene;
        input_scene_points(observed_scene);
        observed_scene.calculate_relations();
        observed_scenes.push_back();
    }    
    
    learn_possible_plans() 
    {
        observed_scene_type observed_scene = observed_scenes.back();
        get_events_from_matching_observed_scene_relation_to_existing_objects();
        get_events_from_matching_observed_scene_relation_to_previous_scenes();  
        
        get_possible_plans_from_events();
    }
    
    get_possible_plans_from_events()
    {
        event_type cause;
        event_type effect;
111111111111111111111111111    
        plan_type possible_plan(cause, effect);
        possible_plans.push_back(possible_plan);
    }
    
    get_events_from_matching_observed_scene_relation_to_existing_objects()
    {
        observed_scene_type observed_scene = observed_scenes.back();
        for (relation in observed_scene.relations)
        {
            for (object in objects)
            {
              event_type event = object.calculate_event_from_relation_move(observed_scene, relation);
              events.push_back(event);                
            }
        }    
    }
    
    get_events_from_matching_observed_scene_relation_to_previous_scenes()
    {
        auto it = observed_scenes.rbegin();
        observed_scene_type observed_scene = *it++;
        observed_scene_type prev_observed_scene = *it;
        
        for (relation in observed_scene.relations)
        {
            event_type event = prev_observed_scene.calculate_object_from_relation_move(observed_scene, relation);
            events.push_back(event);
            objects.push_back(object);
            // todo: environment as an object, an object is a part of another object, event, causality between events
        }
    }
    
    assemble_plans_to_achieve_goals()
    {
        for (goal in goals) 
        {
            plan_type plan;
            subgoal = goal;
            while (!achieved(subgoal))
            {
                plan_step = get_plan_by_effect(subgoal);
                plan.add_step_to_plan(plan_step);
                subgoal = plan_step.cause;
            }
            plans.push_back(plan);
        }
    }

    execute_plans();
    {
        for (plan in executed_plans) 
        {
            plan.execute();
        }
    }

    plan_type get_plan_by_effect(event_type effect)
    {
        for (plan in possible_plans) 
        {
            if (plan.effect == effect)
                return plan_step;
        }
        return null;
    }
    
    predict_world();
    calculate_goals();
}


Detection algorithm:


input sensor data frame (scene);
match_observed_scene_relation_to_existing_objects
match_observed_scene_relation_to_previous_scenes


match_observed_scene_relation_to_existing_objects

for each obj having a detected rel
    for each subset of rels which satisfy the obj rel poses
        find transform between obj and scene
        if the scene data and obj after transform are color compatible
            the object is identified
        else if the scene data and obj after transform are partially color compatible
        
        exceptions:
            break;
        
        
        
